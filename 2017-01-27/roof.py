from pyplasm import *
from generalFunctions import *
import math

def calcAngolo((x,y)):
    ''' 
    @param p=(x,y): point 2D
    @return alpha: radiants, angle of vector v generated by the points (0,0) and (x,y)
    '''
    try:
        s=float(math.sqrt(x*x+y*y))
        if x>=0:
            if y>=0: alpha=math.asin(y/s)
            else: alpha=math.pi*2-math.asin(-y/s)
        else :
            if y>=0: alpha=math.pi-math.asin(y/s)
            else: alpha=math.pi+math.asin(-y/s)
        return alpha
    except: return 0.001

def rotatePoint((x,y),alphaI):
    '''
    @param p=(x,y): point 2D
    @param alphaI: radiants, angle
    @return new_p=(new_x,new_y): rotated point of alphaI
    '''
    alphaII=calcAngolo((x,y))
    alpha=alphaII-alphaI
    s=float(math.sqrt(x*x+y*y))
    if 0>alpha: alpha=math.pi*2+alpha
    if alpha>math.pi*2: alpha=alpha-math.pi*2
    if  math.pi/2>alpha>=0:
        x=s*math.cos(alpha)
        y=s*math.sin(alpha)
    elif math.pi>alpha>=math.pi/2:
        alpha=math.pi-alpha
        x=-s*math.cos(alpha)
        y=s*math.sin(alpha)
    elif math.pi*3/2>alpha>=math.pi:
        alpha=alpha-math.pi
        x=-s*math.cos(alpha)
        y=-s*math.sin(alpha)
    elif math.pi*2>alpha>=math.pi*3/2:
        alpha=math.pi*2-alpha
        x=s*math.cos(alpha)
        y=-s*math.sin(alpha)
    #print alpha*360/math.pi/2,alphaI*360/math.pi/2,alphaII*360/math.pi/2,x,y
    return x,y
    
def turnOn((x1,y1),(x2,y2),(x3,y3)):
    '''
    @param p1=(x1,y1),p2=(x2,y2),p3=(x3,y3)
    @return dx,sx: string, Rigth or left
    '''
    a=(x1-x2,y1-y2)
    c=(x3-x2,y3-y2)
    alphaI=calcAngolo(a)
    #print 'a = ',a,'-- c = ',c,'-- alpha = ',alpha/math.pi/2*360
    x,y=rotatePoint(c,alphaI)
    if y>0: return 'dx'
    elif y<0: return 'sx'
    return None
    
def mapTurns(points=[]):
    '''
    @param points: list of points (x,y)
    @return m: dictionary, a dictionary that has 'dx' or 'sx' for each point 
    '''
    m={}
    for i in range(0,len(points)):
        prev=points[i-1]
        if len(points)>i+1:succ=points[i+1] 
        else: succ=points[0]
        curr=points[i]
        m[curr]=turnOn(prev,curr,succ)
    return m

def sumDxSx(m):
    '''
    @param m: a dictionary that has 'dx' or 'sx' for each point 
    @return int, int : number of 'dx' in m , number of 'sx' in m
    '''
    c={'dx':0,'sx':0}
    for p in m:
        if m[p]!=None:c[m[p]]+=1
    return c['dx'],c['sx']
            
def getConvesso(m):
    '''
    @param m:  a dictionary that has 'dx' or 'sx' for each point 
    @return convesso: string, 'dx' or 'sx'
    '''
    dx,sx=sumDxSx(m)
    if dx>sx: convesso='dx'
    else: convesso='sx'
    return convesso

def getAngoli(points):
    '''
    @param points: a  of the linked points
    @return angoli: a dictionary that has the angle for each point 
    '''
    angoli={}
    m=mapTurns(points)
    convesso=getConvesso(m)
    for i in range(0,len(points)):
        xPrev,yPrev=points[i-1]
        if len(points)>i+1:xSucc,ySucc=points[i+1] 
        else: xSucc,ySucc=points[0]
        xCurr,yCurr=points[i]
        
        succ=(xSucc-xCurr,ySucc-yCurr)
        prev=(xPrev-xCurr,yPrev-yCurr)
        curr=(xCurr,yCurr)
        
        alphaI=calcAngolo(prev)
        alphaII=calcAngolo(succ)
        if m[curr]==convesso:
            if alphaI>alphaII: alphaII+=math.pi*2
            angolo=alphaI+(alphaII-alphaI)/2
            if convesso=='sx':angolo+=math.pi
            if angolo>math.pi*2: angolo-=math.pi*2
        else:
            if alphaII>alphaI: alphaI+=math.pi*2
            angolo=alphaII+(alphaI-alphaII)/2
            if angolo>math.pi*2: angolo-=math.pi*2
        angoli[curr]=angolo
    return angoli

def getPoint((xCurr,yCurr),alpha,h):
    '''
    @param curr=(xCurr,yCurr): current point
    @param alpha: radiants
    @param h: int or float
    @return point: float,float,float or int  xP,yP,h
    '''
    s=2
    xP=s*math.cos(alpha)+xCurr
    yP=s*math.sin(alpha)+yCurr
    return xP,yP,h

def getPointsIn(seqOrdinata,h):
    '''
    
    '''
    pointsIn={}
    angoli=getAngoli(seqOrdinata)
    for p in seqOrdinata:
        pointsIn[p]=getPoint(p,angoli[p],h)
    return pointsIn

def transf2Dto3D((x,y)):
    '''
    Take a point in 2D and return a point in 3D
    @param p2D=(x,y)
    @return p3D=(x,y,z) with z=0
    '''
    return x,y,0

def getSeqOrdinata(lines):
    '''
    Generate a list of linked points
    @param lines : list of lines (line=[p1,p2] where p1 and p2 are points)
    @return seq: list of linked points
    '''
    last=lines[0][0]
    seq=[last]
    while len(seq)!=len(lines):
        for l in lines:
            p1,p2=l
            if last==p1:
                if p2 not in seq: 
                    seq.append(p2)
                    last=p2
            elif last==p2:
                if p1 not in seq: 
                    seq.append(p1)
                    last=p1
    return seq

def build_roof(lines,h):
    '''
    Generate a HPC roof
    @param lines: list of lines (line=[p1,p2] where p1 and p2 are points)
    @param h: height
    @return roof: HPC, roof with terrace
    '''
    seq2D=getSeqOrdinata(lines)
    seq3D=[]
    for p in seq2D:
        seq3D.append(transf2Dto3D(p))
    pointsIn=getPointsIn(seq2D,h)
    seq=seq3D+pointsIn.values()
    cells=[]
    for l in lines:
        p1,p2=l
        points=[seq.index(pointsIn[p1])+1,seq.index(pointsIn[p2])+1,seq2D.index(p2)+1,seq2D.index(p1)+1]
        cells.append(points)
    s=MKPOL([seq,cells,None])
    cell=[range(1,len(pointsIn)+1)]
    p=MKPOL([pointsIn.values(),cell,1])
    cells=[]
    m=mapTurns(seq2D)
    convesso=getConvesso(m)
    for i in range(0,len(seq2D)):
        prec=seq2D[i-1]
        if len(seq2D)>i+1:succ=seq2D[i+1] 
        else: succ=seq2D[0]
        curr=seq2D[i]
        if m[curr]!=convesso:
            currIn=pointsIn[curr]
            precIn=pointsIn[prec]
            succIn=pointsIn[succ]
            cells.append(MKPOL([[succIn,currIn,precIn],[[1,2,3]],[1]]))
    #only if there are one or more reflex angles
    if cells!=[]: 
        p = OFFSET([0.2,0.2,0.2])(STRUCT([p]))
        VIEW(p)
        h= OFFSET([0.2,0.2,0.2])(STRUCT(cells))
        VIEW(h)
        panell=DIFFERENCE([p,h])
    s=OFFSET([.2,.2,.2])(s)
    roof=STRUCT([s,p])
    return roof

def ggpl_roof(lines,params,height):
	return applyTexture(T(3)(height)(build_roof(lines,1)),'roof')